/* tslint:disable */
/* eslint-disable */
/**
 * This file was automatically generated by Payload.
 * DO NOT MODIFY IT BY HAND. Instead, modify your source Payload config,
 * and re-run `payload generate:db-schema` to regenerate this file.
 */

import type {} from "@payloadcms/db-postgres";
import {
  pgTable,
  index,
  uniqueIndex,
  foreignKey,
  uuid,
  varchar,
  boolean,
  timestamp,
  numeric,
  serial,
  integer,
  jsonb,
  type AnyPgColumn,
  pgEnum,
} from "@payloadcms/db-postgres/drizzle/pg-core";
import { sql, relations } from "@payloadcms/db-postgres/drizzle";
export const enum_users_role = pgEnum("enum_users_role", ["admin", "user"]);
export const enum_admin_invitations_role = pgEnum(
  "enum_admin_invitations_role",
  ["admin", "user"],
);
export const enum_orders_status = pgEnum("enum_orders_status", [
  "Pending",
  "Queued",
  "Running",
  "Purchased",
  "Fulfilled",
  "Error",
]);
export const enum_orders_vendor = pgEnum("enum_orders_vendor", [
  "SpotHero",
  "ParkWhiz",
  "ParkMobile",
  "AceParking",
]);
export const enum__orders_v_version_status = pgEnum(
  "enum__orders_v_version_status",
  ["Pending", "Queued", "Running", "Purchased", "Fulfilled", "Error"],
);
export const enum__orders_v_version_vendor = pgEnum(
  "enum__orders_v_version_vendor",
  ["SpotHero", "ParkWhiz", "ParkMobile", "AceParking"],
);
export const enum_exports_format = pgEnum("enum_exports_format", [
  "csv",
  "json",
]);
export const enum_exports_sort_order = pgEnum("enum_exports_sort_order", [
  "asc",
  "desc",
]);
export const enum_exports_drafts = pgEnum("enum_exports_drafts", ["yes", "no"]);
export const enum_audit_log_type = pgEnum("enum_audit_log_type", [
  "info",
  "debug",
  "warning",
  "error",
  "audit",
  "security",
  "unknown",
]);
export const enum_payload_jobs_log_task_slug = pgEnum(
  "enum_payload_jobs_log_task_slug",
  ["inline", "createCollectionExport"],
);
export const enum_payload_jobs_log_state = pgEnum(
  "enum_payload_jobs_log_state",
  ["failed", "succeeded"],
);
export const enum_payload_jobs_task_slug = pgEnum(
  "enum_payload_jobs_task_slug",
  ["inline", "createCollectionExport"],
);
export const enum_payload_query_presets_access_read_constraint = pgEnum(
  "enum_payload_query_presets_access_read_constraint",
  ["everyone", "onlyMe", "specificUsers"],
);
export const enum_payload_query_presets_access_update_constraint = pgEnum(
  "enum_payload_query_presets_access_update_constraint",
  ["everyone", "onlyMe", "specificUsers"],
);
export const enum_payload_query_presets_access_delete_constraint = pgEnum(
  "enum_payload_query_presets_access_delete_constraint",
  ["everyone", "onlyMe", "specificUsers"],
);
export const enum_payload_query_presets_related_collection = pgEnum(
  "enum_payload_query_presets_related_collection",
  [
    "users",
    "sessions",
    "accounts",
    "verifications",
    "admin-invitations",
    "orders",
    "files",
    "tags",
  ],
);

export const users = pgTable(
  "users",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    name: varchar("name"),
    email: varchar("email").notNull(),
    emailVerified: boolean("email_verified").notNull().default(false),
    image: varchar("image"),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    username: varchar("username"),
    displayUsername: varchar("display_username"),
    normalizedEmail: varchar("normalized_email"),
    phoneNumber: varchar("phone_number"),
    phoneNumberVerified: boolean("phone_number_verified").default(false),
    role: enum_users_role("role").default("user"),
    banned: boolean("banned").default(false),
    banReason: varchar("ban_reason"),
    banExpires: timestamp("ban_expires", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    verified: boolean("verified"),
    folder: uuid("folder_id").references(() => payload_folders.id, {
      onDelete: "set null",
    }),
    deletedAt: timestamp("deleted_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
  },
  (columns) => [
    uniqueIndex("users_email_idx").on(columns.email),
    index("users_created_at_idx").on(columns.createdAt),
    index("users_updated_at_idx").on(columns.updatedAt),
    uniqueIndex("users_username_idx").on(columns.username),
    uniqueIndex("users_normalized_email_idx").on(columns.normalizedEmail),
    uniqueIndex("users_phone_number_idx").on(columns.phoneNumber),
    index("users_folder_idx").on(columns.folder),
    index("users_deleted_at_idx").on(columns.deletedAt),
  ],
);

export const sessions = pgTable(
  "sessions",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    expiresAt: timestamp("expires_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }).notNull(),
    token: varchar("token").notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    ipAddress: varchar("ip_address"),
    userAgent: varchar("user_agent"),
    user: uuid("user_id")
      .notNull()
      .references(() => users.id, {
        onDelete: "set null",
      }),
    impersonatedBy: uuid("impersonated_by_id").references(() => users.id, {
      onDelete: "set null",
    }),
    folder: uuid("folder_id").references(() => payload_folders.id, {
      onDelete: "set null",
    }),
    deletedAt: timestamp("deleted_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
  },
  (columns) => [
    uniqueIndex("sessions_token_idx").on(columns.token),
    index("sessions_created_at_idx").on(columns.createdAt),
    index("sessions_updated_at_idx").on(columns.updatedAt),
    index("sessions_user_idx").on(columns.user),
    index("sessions_impersonated_by_idx").on(columns.impersonatedBy),
    index("sessions_folder_idx").on(columns.folder),
    index("sessions_deleted_at_idx").on(columns.deletedAt),
  ],
);

export const accounts = pgTable(
  "accounts",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    accountId: varchar("account_id").notNull(),
    providerId: varchar("provider_id").notNull(),
    user: uuid("user_id")
      .notNull()
      .references(() => users.id, {
        onDelete: "set null",
      }),
    accessToken: varchar("access_token"),
    refreshToken: varchar("refresh_token"),
    idToken: varchar("id_token"),
    accessTokenExpiresAt: timestamp("access_token_expires_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    refreshTokenExpiresAt: timestamp("refresh_token_expires_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    scope: varchar("scope"),
    password: varchar("password"),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    folder: uuid("folder_id").references(() => payload_folders.id, {
      onDelete: "set null",
    }),
    deletedAt: timestamp("deleted_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
  },
  (columns) => [
    index("accounts_account_id_idx").on(columns.accountId),
    index("accounts_user_idx").on(columns.user),
    index("accounts_access_token_expires_at_idx").on(
      columns.accessTokenExpiresAt,
    ),
    index("accounts_refresh_token_expires_at_idx").on(
      columns.refreshTokenExpiresAt,
    ),
    index("accounts_created_at_idx").on(columns.createdAt),
    index("accounts_updated_at_idx").on(columns.updatedAt),
    index("accounts_folder_idx").on(columns.folder),
    index("accounts_deleted_at_idx").on(columns.deletedAt),
  ],
);

export const verifications = pgTable(
  "verifications",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    identifier: varchar("identifier").notNull(),
    value: varchar("value").notNull(),
    expiresAt: timestamp("expires_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }).notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    folder: uuid("folder_id").references(() => payload_folders.id, {
      onDelete: "set null",
    }),
    deletedAt: timestamp("deleted_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
  },
  (columns) => [
    index("verifications_identifier_idx").on(columns.identifier),
    index("verifications_expires_at_idx").on(columns.expiresAt),
    index("verifications_created_at_idx").on(columns.createdAt),
    index("verifications_updated_at_idx").on(columns.updatedAt),
    index("verifications_folder_idx").on(columns.folder),
    index("verifications_deleted_at_idx").on(columns.deletedAt),
  ],
);

export const passkeys = pgTable(
  "passkeys",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    name: varchar("name"),
    publicKey: varchar("public_key").notNull(),
    user: uuid("user_id")
      .notNull()
      .references(() => users.id, {
        onDelete: "set null",
      }),
    credentialID: varchar("credential_i_d").notNull(),
    counter: numeric("counter", { mode: "number" }).notNull(),
    deviceType: varchar("device_type").notNull(),
    backedUp: boolean("backed_up").notNull().default(false),
    transports: varchar("transports").notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    aaguid: varchar("aaguid"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => [
    index("passkeys_public_key_idx").on(columns.publicKey),
    index("passkeys_user_idx").on(columns.user),
    index("passkeys_updated_at_idx").on(columns.updatedAt),
  ],
);

export const admin_invitations = pgTable(
  "admin_invitations",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    role: enum_admin_invitations_role("role").notNull().default("admin"),
    token: varchar("token").notNull(),
    folder: uuid("folder_id").references(() => payload_folders.id, {
      onDelete: "set null",
    }),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    deletedAt: timestamp("deleted_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
  },
  (columns) => [
    index("admin_invitations_token_idx").on(columns.token),
    index("admin_invitations_folder_idx").on(columns.folder),
    index("admin_invitations_updated_at_idx").on(columns.updatedAt),
    index("admin_invitations_created_at_idx").on(columns.createdAt),
    index("admin_invitations_deleted_at_idx").on(columns.deletedAt),
  ],
);

export const orders = pgTable(
  "orders",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    sessionId: varchar("session_id"),
    sessionURL: varchar("session_u_r_l"),
    orderNumber: numeric("order_number", { mode: "number" }),
    status: enum_orders_status("status"),
    orderLink: varchar("order_link"),
    value: numeric("value", { mode: "number" }),
    event: varchar("event"),
    venue: varchar("venue"),
    location: varchar("location"),
    vendor: enum_orders_vendor("vendor"),
    link: varchar("link"),
    price: numeric("price", { mode: "number" }),
    PDF: uuid("pdf_id").references(() => files.id, {
      onDelete: "set null",
    }),
    notes: varchar("notes"),
    folder: uuid("folder_id").references(() => payload_folders.id, {
      onDelete: "set null",
    }),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    deletedAt: timestamp("deleted_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    _status: enum_orders_status("_status").default("draft"),
  },
  (columns) => [
    index("orders_pdf_idx").on(columns.PDF),
    index("orders_folder_idx").on(columns.folder),
    index("orders_updated_at_idx").on(columns.updatedAt),
    index("orders_created_at_idx").on(columns.createdAt),
    index("orders_deleted_at_idx").on(columns.deletedAt),
    index("orders__status_idx").on(columns._status),
  ],
);

export const orders_rels = pgTable(
  "orders_rels",
  {
    id: serial("id").primaryKey(),
    order: integer("order"),
    parent: uuid("parent_id").notNull(),
    path: varchar("path").notNull(),
    tagsID: uuid("tags_id"),
  },
  (columns) => [
    index("orders_rels_order_idx").on(columns.order),
    index("orders_rels_parent_idx").on(columns.parent),
    index("orders_rels_path_idx").on(columns.path),
    index("orders_rels_tags_id_idx").on(columns.tagsID),
    foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [orders.id],
      name: "orders_rels_parent_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["tagsID"]],
      foreignColumns: [tags.id],
      name: "orders_rels_tags_fk",
    }).onDelete("cascade"),
  ],
);

export const _orders_v = pgTable(
  "_orders_v",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    parent: uuid("parent_id").references(() => orders.id, {
      onDelete: "set null",
    }),
    version_sessionId: varchar("version_session_id"),
    version_sessionURL: varchar("version_session_u_r_l"),
    version_orderNumber: numeric("version_order_number", { mode: "number" }),
    version_status: enum__orders_v_version_status("version_status"),
    version_orderLink: varchar("version_order_link"),
    version_value: numeric("version_value", { mode: "number" }),
    version_event: varchar("version_event"),
    version_venue: varchar("version_venue"),
    version_location: varchar("version_location"),
    version_vendor: enum__orders_v_version_vendor("version_vendor"),
    version_link: varchar("version_link"),
    version_price: numeric("version_price", { mode: "number" }),
    version_PDF: uuid("version_pdf_id").references(() => files.id, {
      onDelete: "set null",
    }),
    version_notes: varchar("version_notes"),
    version_folder: uuid("version_folder_id").references(
      () => payload_folders.id,
      {
        onDelete: "set null",
      },
    ),
    version_updatedAt: timestamp("version_updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    version_createdAt: timestamp("version_created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    version_deletedAt: timestamp("version_deleted_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    version__status:
      enum__orders_v_version_status("version__status").default("draft"),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    latest: boolean("latest"),
    autosave: boolean("autosave"),
  },
  (columns) => [
    index("_orders_v_parent_idx").on(columns.parent),
    index("_orders_v_version_version_pdf_idx").on(columns.version_PDF),
    index("_orders_v_version_version_folder_idx").on(columns.version_folder),
    index("_orders_v_version_version_updated_at_idx").on(
      columns.version_updatedAt,
    ),
    index("_orders_v_version_version_created_at_idx").on(
      columns.version_createdAt,
    ),
    index("_orders_v_version_version_deleted_at_idx").on(
      columns.version_deletedAt,
    ),
    index("_orders_v_version_version__status_idx").on(columns.version__status),
    index("_orders_v_created_at_idx").on(columns.createdAt),
    index("_orders_v_updated_at_idx").on(columns.updatedAt),
    index("_orders_v_latest_idx").on(columns.latest),
    index("_orders_v_autosave_idx").on(columns.autosave),
  ],
);

export const _orders_v_rels = pgTable(
  "_orders_v_rels",
  {
    id: serial("id").primaryKey(),
    order: integer("order"),
    parent: uuid("parent_id").notNull(),
    path: varchar("path").notNull(),
    tagsID: uuid("tags_id"),
  },
  (columns) => [
    index("_orders_v_rels_order_idx").on(columns.order),
    index("_orders_v_rels_parent_idx").on(columns.parent),
    index("_orders_v_rels_path_idx").on(columns.path),
    index("_orders_v_rels_tags_id_idx").on(columns.tagsID),
    foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [_orders_v.id],
      name: "_orders_v_rels_parent_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["tagsID"]],
      foreignColumns: [tags.id],
      name: "_orders_v_rels_tags_fk",
    }).onDelete("cascade"),
  ],
);

export const files = pgTable(
  "files",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    notes: varchar("notes"),
    prefix: varchar("prefix").default("files"),
    folder: uuid("folder_id").references(() => payload_folders.id, {
      onDelete: "set null",
    }),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    deletedAt: timestamp("deleted_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    url: varchar("url"),
    thumbnailURL: varchar("thumbnail_u_r_l"),
    filename: varchar("filename"),
    mimeType: varchar("mime_type"),
    filesize: numeric("filesize", { mode: "number" }),
    width: numeric("width", { mode: "number" }),
    height: numeric("height", { mode: "number" }),
    focalX: numeric("focal_x", { mode: "number" }),
    focalY: numeric("focal_y", { mode: "number" }),
    sizes_thumbnail_url: varchar("sizes_thumbnail_url"),
    sizes_thumbnail_width: numeric("sizes_thumbnail_width", { mode: "number" }),
    sizes_thumbnail_height: numeric("sizes_thumbnail_height", {
      mode: "number",
    }),
    sizes_thumbnail_mimeType: varchar("sizes_thumbnail_mime_type"),
    sizes_thumbnail_filesize: numeric("sizes_thumbnail_filesize", {
      mode: "number",
    }),
    sizes_thumbnail_filename: varchar("sizes_thumbnail_filename"),
    sizes_square_url: varchar("sizes_square_url"),
    sizes_square_width: numeric("sizes_square_width", { mode: "number" }),
    sizes_square_height: numeric("sizes_square_height", { mode: "number" }),
    sizes_square_mimeType: varchar("sizes_square_mime_type"),
    sizes_square_filesize: numeric("sizes_square_filesize", { mode: "number" }),
    sizes_square_filename: varchar("sizes_square_filename"),
    sizes_small_url: varchar("sizes_small_url"),
    sizes_small_width: numeric("sizes_small_width", { mode: "number" }),
    sizes_small_height: numeric("sizes_small_height", { mode: "number" }),
    sizes_small_mimeType: varchar("sizes_small_mime_type"),
    sizes_small_filesize: numeric("sizes_small_filesize", { mode: "number" }),
    sizes_small_filename: varchar("sizes_small_filename"),
    sizes_medium_url: varchar("sizes_medium_url"),
    sizes_medium_width: numeric("sizes_medium_width", { mode: "number" }),
    sizes_medium_height: numeric("sizes_medium_height", { mode: "number" }),
    sizes_medium_mimeType: varchar("sizes_medium_mime_type"),
    sizes_medium_filesize: numeric("sizes_medium_filesize", { mode: "number" }),
    sizes_medium_filename: varchar("sizes_medium_filename"),
    sizes_large_url: varchar("sizes_large_url"),
    sizes_large_width: numeric("sizes_large_width", { mode: "number" }),
    sizes_large_height: numeric("sizes_large_height", { mode: "number" }),
    sizes_large_mimeType: varchar("sizes_large_mime_type"),
    sizes_large_filesize: numeric("sizes_large_filesize", { mode: "number" }),
    sizes_large_filename: varchar("sizes_large_filename"),
    sizes_xlarge_url: varchar("sizes_xlarge_url"),
    sizes_xlarge_width: numeric("sizes_xlarge_width", { mode: "number" }),
    sizes_xlarge_height: numeric("sizes_xlarge_height", { mode: "number" }),
    sizes_xlarge_mimeType: varchar("sizes_xlarge_mime_type"),
    sizes_xlarge_filesize: numeric("sizes_xlarge_filesize", { mode: "number" }),
    sizes_xlarge_filename: varchar("sizes_xlarge_filename"),
    sizes_og_url: varchar("sizes_og_url"),
    sizes_og_width: numeric("sizes_og_width", { mode: "number" }),
    sizes_og_height: numeric("sizes_og_height", { mode: "number" }),
    sizes_og_mimeType: varchar("sizes_og_mime_type"),
    sizes_og_filesize: numeric("sizes_og_filesize", { mode: "number" }),
    sizes_og_filename: varchar("sizes_og_filename"),
  },
  (columns) => [
    index("files_folder_idx").on(columns.folder),
    index("files_updated_at_idx").on(columns.updatedAt),
    index("files_created_at_idx").on(columns.createdAt),
    index("files_deleted_at_idx").on(columns.deletedAt),
    uniqueIndex("files_filename_idx").on(columns.filename),
    index("files_sizes_thumbnail_sizes_thumbnail_filename_idx").on(
      columns.sizes_thumbnail_filename,
    ),
    index("files_sizes_square_sizes_square_filename_idx").on(
      columns.sizes_square_filename,
    ),
    index("files_sizes_small_sizes_small_filename_idx").on(
      columns.sizes_small_filename,
    ),
    index("files_sizes_medium_sizes_medium_filename_idx").on(
      columns.sizes_medium_filename,
    ),
    index("files_sizes_large_sizes_large_filename_idx").on(
      columns.sizes_large_filename,
    ),
    index("files_sizes_xlarge_sizes_xlarge_filename_idx").on(
      columns.sizes_xlarge_filename,
    ),
    index("files_sizes_og_sizes_og_filename_idx").on(columns.sizes_og_filename),
  ],
);

export const files_rels = pgTable(
  "files_rels",
  {
    id: serial("id").primaryKey(),
    order: integer("order"),
    parent: uuid("parent_id").notNull(),
    path: varchar("path").notNull(),
    tagsID: uuid("tags_id"),
  },
  (columns) => [
    index("files_rels_order_idx").on(columns.order),
    index("files_rels_parent_idx").on(columns.parent),
    index("files_rels_path_idx").on(columns.path),
    index("files_rels_tags_id_idx").on(columns.tagsID),
    foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [files.id],
      name: "files_rels_parent_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["tagsID"]],
      foreignColumns: [tags.id],
      name: "files_rels_tags_fk",
    }).onDelete("cascade"),
  ],
);

export const tags = pgTable(
  "tags",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    name: varchar("name").notNull(),
    description: varchar("description"),
    folder: uuid("folder_id").references(() => payload_folders.id, {
      onDelete: "set null",
    }),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    deletedAt: timestamp("deleted_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
  },
  (columns) => [
    index("tags_folder_idx").on(columns.folder),
    index("tags_updated_at_idx").on(columns.updatedAt),
    index("tags_created_at_idx").on(columns.createdAt),
    index("tags_deleted_at_idx").on(columns.deletedAt),
  ],
);

export const exports = pgTable(
  "exports",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    name: varchar("name"),
    format: enum_exports_format("format").default("csv"),
    limit: numeric("limit", { mode: "number" }),
    page: numeric("page", { mode: "number" }).default("1"),
    sort: varchar("sort"),
    sortOrder: enum_exports_sort_order("sort_order"),
    drafts: enum_exports_drafts("drafts").default("yes"),
    collectionSlug: varchar("collection_slug").notNull(),
    where: jsonb("where").default(sql`'{}'::jsonb`),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    url: varchar("url"),
    thumbnailURL: varchar("thumbnail_u_r_l"),
    filename: varchar("filename"),
    mimeType: varchar("mime_type"),
    filesize: numeric("filesize", { mode: "number" }),
    width: numeric("width", { mode: "number" }),
    height: numeric("height", { mode: "number" }),
    focalX: numeric("focal_x", { mode: "number" }),
    focalY: numeric("focal_y", { mode: "number" }),
  },
  (columns) => [
    index("exports_updated_at_idx").on(columns.updatedAt),
    index("exports_created_at_idx").on(columns.createdAt),
    uniqueIndex("exports_filename_idx").on(columns.filename),
  ],
);

export const exports_texts = pgTable(
  "exports_texts",
  {
    id: serial("id").primaryKey(),
    order: integer("order").notNull(),
    parent: uuid("parent_id").notNull(),
    path: varchar("path").notNull(),
    text: varchar("text"),
  },
  (columns) => [
    index("exports_texts_order_parent").on(columns.order, columns.parent),
    foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [exports.id],
      name: "exports_texts_parent_fk",
    }).onDelete("cascade"),
  ],
);

export const audit_log = pgTable(
  "audit_log",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    operation: varchar("operation").notNull(),
    collection: varchar("collection").notNull(),
    documentId: varchar("document_id"),
    user: uuid("user_id")
      .notNull()
      .references(() => users.id, {
        onDelete: "set null",
      }),
    userAgent: varchar("user_agent"),
    hook: varchar("hook"),
    type: enum_audit_log_type("type").notNull().default("info"),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }).notNull(),
  },
  (columns) => [index("audit_log_user_idx").on(columns.user)],
);

export const payload_jobs_log = pgTable(
  "payload_jobs_log",
  {
    _order: integer("_order").notNull(),
    _parentID: uuid("_parent_id").notNull(),
    id: varchar("id").primaryKey(),
    executedAt: timestamp("executed_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }).notNull(),
    completedAt: timestamp("completed_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }).notNull(),
    taskSlug: enum_payload_jobs_log_task_slug("task_slug").notNull(),
    taskID: varchar("task_i_d").notNull(),
    input: jsonb("input"),
    output: jsonb("output"),
    state: enum_payload_jobs_log_state("state").notNull(),
    error: jsonb("error"),
  },
  (columns) => [
    index("payload_jobs_log_order_idx").on(columns._order),
    index("payload_jobs_log_parent_id_idx").on(columns._parentID),
    foreignKey({
      columns: [columns["_parentID"]],
      foreignColumns: [payload_jobs.id],
      name: "payload_jobs_log_parent_id_fk",
    }).onDelete("cascade"),
  ],
);

export const payload_jobs = pgTable(
  "payload_jobs",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    input: jsonb("input"),
    completedAt: timestamp("completed_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    totalTried: numeric("total_tried", { mode: "number" }).default("0"),
    hasError: boolean("has_error").default(false),
    error: jsonb("error"),
    taskSlug: enum_payload_jobs_task_slug("task_slug"),
    queue: varchar("queue").default("default"),
    waitUntil: timestamp("wait_until", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    }),
    processing: boolean("processing").default(false),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => [
    index("payload_jobs_completed_at_idx").on(columns.completedAt),
    index("payload_jobs_total_tried_idx").on(columns.totalTried),
    index("payload_jobs_has_error_idx").on(columns.hasError),
    index("payload_jobs_task_slug_idx").on(columns.taskSlug),
    index("payload_jobs_queue_idx").on(columns.queue),
    index("payload_jobs_wait_until_idx").on(columns.waitUntil),
    index("payload_jobs_processing_idx").on(columns.processing),
    index("payload_jobs_updated_at_idx").on(columns.updatedAt),
    index("payload_jobs_created_at_idx").on(columns.createdAt),
  ],
);

export const payload_folders = pgTable(
  "payload_folders",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    name: varchar("name").notNull(),
    folder: uuid("folder_id").references(
      (): AnyPgColumn => payload_folders.id,
      {
        onDelete: "set null",
      },
    ),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => [
    index("payload_folders_name_idx").on(columns.name),
    index("payload_folders_folder_idx").on(columns.folder),
    index("payload_folders_updated_at_idx").on(columns.updatedAt),
    index("payload_folders_created_at_idx").on(columns.createdAt),
  ],
);

export const payload_locked_documents = pgTable(
  "payload_locked_documents",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    globalSlug: varchar("global_slug"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => [
    index("payload_locked_documents_global_slug_idx").on(columns.globalSlug),
    index("payload_locked_documents_updated_at_idx").on(columns.updatedAt),
    index("payload_locked_documents_created_at_idx").on(columns.createdAt),
  ],
);

export const payload_locked_documents_rels = pgTable(
  "payload_locked_documents_rels",
  {
    id: serial("id").primaryKey(),
    order: integer("order"),
    parent: uuid("parent_id").notNull(),
    path: varchar("path").notNull(),
    usersID: uuid("users_id"),
    sessionsID: uuid("sessions_id"),
    accountsID: uuid("accounts_id"),
    verificationsID: uuid("verifications_id"),
    passkeysID: uuid("passkeys_id"),
    "admin-invitationsID": uuid("admin_invitations_id"),
    ordersID: uuid("orders_id"),
    filesID: uuid("files_id"),
    tagsID: uuid("tags_id"),
    exportsID: uuid("exports_id"),
    "Audit-logID": uuid("audit_log_id"),
    "payload-jobsID": uuid("payload_jobs_id"),
    "payload-foldersID": uuid("payload_folders_id"),
  },
  (columns) => [
    index("payload_locked_documents_rels_order_idx").on(columns.order),
    index("payload_locked_documents_rels_parent_idx").on(columns.parent),
    index("payload_locked_documents_rels_path_idx").on(columns.path),
    index("payload_locked_documents_rels_users_id_idx").on(columns.usersID),
    index("payload_locked_documents_rels_sessions_id_idx").on(
      columns.sessionsID,
    ),
    index("payload_locked_documents_rels_accounts_id_idx").on(
      columns.accountsID,
    ),
    index("payload_locked_documents_rels_verifications_id_idx").on(
      columns.verificationsID,
    ),
    index("payload_locked_documents_rels_passkeys_id_idx").on(
      columns.passkeysID,
    ),
    index("payload_locked_documents_rels_admin_invitations_id_idx").on(
      columns["admin-invitationsID"],
    ),
    index("payload_locked_documents_rels_orders_id_idx").on(columns.ordersID),
    index("payload_locked_documents_rels_files_id_idx").on(columns.filesID),
    index("payload_locked_documents_rels_tags_id_idx").on(columns.tagsID),
    index("payload_locked_documents_rels_exports_id_idx").on(columns.exportsID),
    index("payload_locked_documents_rels_audit_log_id_idx").on(
      columns["Audit-logID"],
    ),
    index("payload_locked_documents_rels_payload_jobs_id_idx").on(
      columns["payload-jobsID"],
    ),
    index("payload_locked_documents_rels_payload_folders_id_idx").on(
      columns["payload-foldersID"],
    ),
    foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [payload_locked_documents.id],
      name: "payload_locked_documents_rels_parent_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["usersID"]],
      foreignColumns: [users.id],
      name: "payload_locked_documents_rels_users_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["sessionsID"]],
      foreignColumns: [sessions.id],
      name: "payload_locked_documents_rels_sessions_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["accountsID"]],
      foreignColumns: [accounts.id],
      name: "payload_locked_documents_rels_accounts_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["verificationsID"]],
      foreignColumns: [verifications.id],
      name: "payload_locked_documents_rels_verifications_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["passkeysID"]],
      foreignColumns: [passkeys.id],
      name: "payload_locked_documents_rels_passkeys_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["admin-invitationsID"]],
      foreignColumns: [admin_invitations.id],
      name: "payload_locked_documents_rels_admin_invitations_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["ordersID"]],
      foreignColumns: [orders.id],
      name: "payload_locked_documents_rels_orders_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["filesID"]],
      foreignColumns: [files.id],
      name: "payload_locked_documents_rels_files_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["tagsID"]],
      foreignColumns: [tags.id],
      name: "payload_locked_documents_rels_tags_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["exportsID"]],
      foreignColumns: [exports.id],
      name: "payload_locked_documents_rels_exports_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["Audit-logID"]],
      foreignColumns: [audit_log.id],
      name: "payload_locked_documents_rels_audit_log_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["payload-jobsID"]],
      foreignColumns: [payload_jobs.id],
      name: "payload_locked_documents_rels_payload_jobs_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["payload-foldersID"]],
      foreignColumns: [payload_folders.id],
      name: "payload_locked_documents_rels_payload_folders_fk",
    }).onDelete("cascade"),
  ],
);

export const payload_preferences = pgTable(
  "payload_preferences",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    key: varchar("key"),
    value: jsonb("value"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => [
    index("payload_preferences_key_idx").on(columns.key),
    index("payload_preferences_updated_at_idx").on(columns.updatedAt),
    index("payload_preferences_created_at_idx").on(columns.createdAt),
  ],
);

export const payload_preferences_rels = pgTable(
  "payload_preferences_rels",
  {
    id: serial("id").primaryKey(),
    order: integer("order"),
    parent: uuid("parent_id").notNull(),
    path: varchar("path").notNull(),
    usersID: uuid("users_id"),
  },
  (columns) => [
    index("payload_preferences_rels_order_idx").on(columns.order),
    index("payload_preferences_rels_parent_idx").on(columns.parent),
    index("payload_preferences_rels_path_idx").on(columns.path),
    index("payload_preferences_rels_users_id_idx").on(columns.usersID),
    foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [payload_preferences.id],
      name: "payload_preferences_rels_parent_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["usersID"]],
      foreignColumns: [users.id],
      name: "payload_preferences_rels_users_fk",
    }).onDelete("cascade"),
  ],
);

export const payload_migrations = pgTable(
  "payload_migrations",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    name: varchar("name"),
    batch: numeric("batch", { mode: "number" }),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => [
    index("payload_migrations_updated_at_idx").on(columns.updatedAt),
    index("payload_migrations_created_at_idx").on(columns.createdAt),
  ],
);

export const payload_query_presets = pgTable(
  "payload_query_presets",
  {
    id: uuid("id").defaultRandom().primaryKey(),
    title: varchar("title").notNull(),
    isShared: boolean("is_shared").default(false),
    access_read_constraint: enum_payload_query_presets_access_read_constraint(
      "access_read_constraint",
    ).default("onlyMe"),
    access_update_constraint:
      enum_payload_query_presets_access_update_constraint(
        "access_update_constraint",
      ).default("onlyMe"),
    access_delete_constraint:
      enum_payload_query_presets_access_delete_constraint(
        "access_delete_constraint",
      ).default("onlyMe"),
    where: jsonb("where"),
    columns: jsonb("columns"),
    relatedCollection:
      enum_payload_query_presets_related_collection(
        "related_collection",
      ).notNull(),
    isTemp: boolean("is_temp"),
    updatedAt: timestamp("updated_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
    createdAt: timestamp("created_at", {
      mode: "string",
      withTimezone: true,
      precision: 3,
    })
      .defaultNow()
      .notNull(),
  },
  (columns) => [
    index("payload_query_presets_updated_at_idx").on(columns.updatedAt),
    index("payload_query_presets_created_at_idx").on(columns.createdAt),
  ],
);

export const payload_query_presets_rels = pgTable(
  "payload_query_presets_rels",
  {
    id: serial("id").primaryKey(),
    order: integer("order"),
    parent: uuid("parent_id").notNull(),
    path: varchar("path").notNull(),
    usersID: uuid("users_id"),
  },
  (columns) => [
    index("payload_query_presets_rels_order_idx").on(columns.order),
    index("payload_query_presets_rels_parent_idx").on(columns.parent),
    index("payload_query_presets_rels_path_idx").on(columns.path),
    index("payload_query_presets_rels_users_id_idx").on(columns.usersID),
    foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [payload_query_presets.id],
      name: "payload_query_presets_rels_parent_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["usersID"]],
      foreignColumns: [users.id],
      name: "payload_query_presets_rels_users_fk",
    }).onDelete("cascade"),
  ],
);

export const settings = pgTable("settings", {
  id: uuid("id").defaultRandom().primaryKey(),
  updatedAt: timestamp("updated_at", {
    mode: "string",
    withTimezone: true,
    precision: 3,
  }),
  createdAt: timestamp("created_at", {
    mode: "string",
    withTimezone: true,
    precision: 3,
  }),
});

export const settings_rels = pgTable(
  "settings_rels",
  {
    id: serial("id").primaryKey(),
    order: integer("order"),
    parent: uuid("parent_id").notNull(),
    path: varchar("path").notNull(),
    filesID: uuid("files_id"),
  },
  (columns) => [
    index("settings_rels_order_idx").on(columns.order),
    index("settings_rels_parent_idx").on(columns.parent),
    index("settings_rels_path_idx").on(columns.path),
    index("settings_rels_files_id_idx").on(columns.filesID),
    foreignKey({
      columns: [columns["parent"]],
      foreignColumns: [settings.id],
      name: "settings_rels_parent_fk",
    }).onDelete("cascade"),
    foreignKey({
      columns: [columns["filesID"]],
      foreignColumns: [files.id],
      name: "settings_rels_files_fk",
    }).onDelete("cascade"),
  ],
);

export const relations_users = relations(users, ({ one }) => ({
  folder: one(payload_folders, {
    fields: [users.folder],
    references: [payload_folders.id],
    relationName: "folder",
  }),
}));
export const relations_sessions = relations(sessions, ({ one }) => ({
  user: one(users, {
    fields: [sessions.user],
    references: [users.id],
    relationName: "user",
  }),
  impersonatedBy: one(users, {
    fields: [sessions.impersonatedBy],
    references: [users.id],
    relationName: "impersonatedBy",
  }),
  folder: one(payload_folders, {
    fields: [sessions.folder],
    references: [payload_folders.id],
    relationName: "folder",
  }),
}));
export const relations_accounts = relations(accounts, ({ one }) => ({
  user: one(users, {
    fields: [accounts.user],
    references: [users.id],
    relationName: "user",
  }),
  folder: one(payload_folders, {
    fields: [accounts.folder],
    references: [payload_folders.id],
    relationName: "folder",
  }),
}));
export const relations_verifications = relations(verifications, ({ one }) => ({
  folder: one(payload_folders, {
    fields: [verifications.folder],
    references: [payload_folders.id],
    relationName: "folder",
  }),
}));
export const relations_passkeys = relations(passkeys, ({ one }) => ({
  user: one(users, {
    fields: [passkeys.user],
    references: [users.id],
    relationName: "user",
  }),
}));
export const relations_admin_invitations = relations(
  admin_invitations,
  ({ one }) => ({
    folder: one(payload_folders, {
      fields: [admin_invitations.folder],
      references: [payload_folders.id],
      relationName: "folder",
    }),
  }),
);
export const relations_orders_rels = relations(orders_rels, ({ one }) => ({
  parent: one(orders, {
    fields: [orders_rels.parent],
    references: [orders.id],
    relationName: "_rels",
  }),
  tagsID: one(tags, {
    fields: [orders_rels.tagsID],
    references: [tags.id],
    relationName: "tags",
  }),
}));
export const relations_orders = relations(orders, ({ one, many }) => ({
  PDF: one(files, {
    fields: [orders.PDF],
    references: [files.id],
    relationName: "PDF",
  }),
  folder: one(payload_folders, {
    fields: [orders.folder],
    references: [payload_folders.id],
    relationName: "folder",
  }),
  _rels: many(orders_rels, {
    relationName: "_rels",
  }),
}));
export const relations__orders_v_rels = relations(
  _orders_v_rels,
  ({ one }) => ({
    parent: one(_orders_v, {
      fields: [_orders_v_rels.parent],
      references: [_orders_v.id],
      relationName: "_rels",
    }),
    tagsID: one(tags, {
      fields: [_orders_v_rels.tagsID],
      references: [tags.id],
      relationName: "tags",
    }),
  }),
);
export const relations__orders_v = relations(_orders_v, ({ one, many }) => ({
  parent: one(orders, {
    fields: [_orders_v.parent],
    references: [orders.id],
    relationName: "parent",
  }),
  version_PDF: one(files, {
    fields: [_orders_v.version_PDF],
    references: [files.id],
    relationName: "version_PDF",
  }),
  version_folder: one(payload_folders, {
    fields: [_orders_v.version_folder],
    references: [payload_folders.id],
    relationName: "version_folder",
  }),
  _rels: many(_orders_v_rels, {
    relationName: "_rels",
  }),
}));
export const relations_files_rels = relations(files_rels, ({ one }) => ({
  parent: one(files, {
    fields: [files_rels.parent],
    references: [files.id],
    relationName: "_rels",
  }),
  tagsID: one(tags, {
    fields: [files_rels.tagsID],
    references: [tags.id],
    relationName: "tags",
  }),
}));
export const relations_files = relations(files, ({ one, many }) => ({
  folder: one(payload_folders, {
    fields: [files.folder],
    references: [payload_folders.id],
    relationName: "folder",
  }),
  _rels: many(files_rels, {
    relationName: "_rels",
  }),
}));
export const relations_tags = relations(tags, ({ one }) => ({
  folder: one(payload_folders, {
    fields: [tags.folder],
    references: [payload_folders.id],
    relationName: "folder",
  }),
}));
export const relations_exports_texts = relations(exports_texts, ({ one }) => ({
  parent: one(exports, {
    fields: [exports_texts.parent],
    references: [exports.id],
    relationName: "_texts",
  }),
}));
export const relations_exports = relations(exports, ({ many }) => ({
  _texts: many(exports_texts, {
    relationName: "_texts",
  }),
}));
export const relations_audit_log = relations(audit_log, ({ one }) => ({
  user: one(users, {
    fields: [audit_log.user],
    references: [users.id],
    relationName: "user",
  }),
}));
export const relations_payload_jobs_log = relations(
  payload_jobs_log,
  ({ one }) => ({
    _parentID: one(payload_jobs, {
      fields: [payload_jobs_log._parentID],
      references: [payload_jobs.id],
      relationName: "log",
    }),
  }),
);
export const relations_payload_jobs = relations(payload_jobs, ({ many }) => ({
  log: many(payload_jobs_log, {
    relationName: "log",
  }),
}));
export const relations_payload_folders = relations(
  payload_folders,
  ({ one }) => ({
    folder: one(payload_folders, {
      fields: [payload_folders.folder],
      references: [payload_folders.id],
      relationName: "folder",
    }),
  }),
);
export const relations_payload_locked_documents_rels = relations(
  payload_locked_documents_rels,
  ({ one }) => ({
    parent: one(payload_locked_documents, {
      fields: [payload_locked_documents_rels.parent],
      references: [payload_locked_documents.id],
      relationName: "_rels",
    }),
    usersID: one(users, {
      fields: [payload_locked_documents_rels.usersID],
      references: [users.id],
      relationName: "users",
    }),
    sessionsID: one(sessions, {
      fields: [payload_locked_documents_rels.sessionsID],
      references: [sessions.id],
      relationName: "sessions",
    }),
    accountsID: one(accounts, {
      fields: [payload_locked_documents_rels.accountsID],
      references: [accounts.id],
      relationName: "accounts",
    }),
    verificationsID: one(verifications, {
      fields: [payload_locked_documents_rels.verificationsID],
      references: [verifications.id],
      relationName: "verifications",
    }),
    passkeysID: one(passkeys, {
      fields: [payload_locked_documents_rels.passkeysID],
      references: [passkeys.id],
      relationName: "passkeys",
    }),
    "admin-invitationsID": one(admin_invitations, {
      fields: [payload_locked_documents_rels["admin-invitationsID"]],
      references: [admin_invitations.id],
      relationName: "admin-invitations",
    }),
    ordersID: one(orders, {
      fields: [payload_locked_documents_rels.ordersID],
      references: [orders.id],
      relationName: "orders",
    }),
    filesID: one(files, {
      fields: [payload_locked_documents_rels.filesID],
      references: [files.id],
      relationName: "files",
    }),
    tagsID: one(tags, {
      fields: [payload_locked_documents_rels.tagsID],
      references: [tags.id],
      relationName: "tags",
    }),
    exportsID: one(exports, {
      fields: [payload_locked_documents_rels.exportsID],
      references: [exports.id],
      relationName: "exports",
    }),
    "Audit-logID": one(audit_log, {
      fields: [payload_locked_documents_rels["Audit-logID"]],
      references: [audit_log.id],
      relationName: "Audit-log",
    }),
    "payload-jobsID": one(payload_jobs, {
      fields: [payload_locked_documents_rels["payload-jobsID"]],
      references: [payload_jobs.id],
      relationName: "payload-jobs",
    }),
    "payload-foldersID": one(payload_folders, {
      fields: [payload_locked_documents_rels["payload-foldersID"]],
      references: [payload_folders.id],
      relationName: "payload-folders",
    }),
  }),
);
export const relations_payload_locked_documents = relations(
  payload_locked_documents,
  ({ many }) => ({
    _rels: many(payload_locked_documents_rels, {
      relationName: "_rels",
    }),
  }),
);
export const relations_payload_preferences_rels = relations(
  payload_preferences_rels,
  ({ one }) => ({
    parent: one(payload_preferences, {
      fields: [payload_preferences_rels.parent],
      references: [payload_preferences.id],
      relationName: "_rels",
    }),
    usersID: one(users, {
      fields: [payload_preferences_rels.usersID],
      references: [users.id],
      relationName: "users",
    }),
  }),
);
export const relations_payload_preferences = relations(
  payload_preferences,
  ({ many }) => ({
    _rels: many(payload_preferences_rels, {
      relationName: "_rels",
    }),
  }),
);
export const relations_payload_migrations = relations(
  payload_migrations,
  () => ({}),
);
export const relations_payload_query_presets_rels = relations(
  payload_query_presets_rels,
  ({ one }) => ({
    parent: one(payload_query_presets, {
      fields: [payload_query_presets_rels.parent],
      references: [payload_query_presets.id],
      relationName: "_rels",
    }),
    usersID: one(users, {
      fields: [payload_query_presets_rels.usersID],
      references: [users.id],
      relationName: "users",
    }),
  }),
);
export const relations_payload_query_presets = relations(
  payload_query_presets,
  ({ many }) => ({
    _rels: many(payload_query_presets_rels, {
      relationName: "_rels",
    }),
  }),
);
export const relations_settings_rels = relations(settings_rels, ({ one }) => ({
  parent: one(settings, {
    fields: [settings_rels.parent],
    references: [settings.id],
    relationName: "_rels",
  }),
  filesID: one(files, {
    fields: [settings_rels.filesID],
    references: [files.id],
    relationName: "files",
  }),
}));
export const relations_settings = relations(settings, ({ many }) => ({
  _rels: many(settings_rels, {
    relationName: "_rels",
  }),
}));

type DatabaseSchema = {
  enum_users_role: typeof enum_users_role;
  enum_admin_invitations_role: typeof enum_admin_invitations_role;
  enum_orders_status: typeof enum_orders_status;
  enum_orders_vendor: typeof enum_orders_vendor;
  enum__orders_v_version_status: typeof enum__orders_v_version_status;
  enum__orders_v_version_vendor: typeof enum__orders_v_version_vendor;
  enum_exports_format: typeof enum_exports_format;
  enum_exports_sort_order: typeof enum_exports_sort_order;
  enum_exports_drafts: typeof enum_exports_drafts;
  enum_audit_log_type: typeof enum_audit_log_type;
  enum_payload_jobs_log_task_slug: typeof enum_payload_jobs_log_task_slug;
  enum_payload_jobs_log_state: typeof enum_payload_jobs_log_state;
  enum_payload_jobs_task_slug: typeof enum_payload_jobs_task_slug;
  enum_payload_query_presets_access_read_constraint: typeof enum_payload_query_presets_access_read_constraint;
  enum_payload_query_presets_access_update_constraint: typeof enum_payload_query_presets_access_update_constraint;
  enum_payload_query_presets_access_delete_constraint: typeof enum_payload_query_presets_access_delete_constraint;
  enum_payload_query_presets_related_collection: typeof enum_payload_query_presets_related_collection;
  users: typeof users;
  sessions: typeof sessions;
  accounts: typeof accounts;
  verifications: typeof verifications;
  passkeys: typeof passkeys;
  admin_invitations: typeof admin_invitations;
  orders: typeof orders;
  orders_rels: typeof orders_rels;
  _orders_v: typeof _orders_v;
  _orders_v_rels: typeof _orders_v_rels;
  files: typeof files;
  files_rels: typeof files_rels;
  tags: typeof tags;
  exports: typeof exports;
  exports_texts: typeof exports_texts;
  audit_log: typeof audit_log;
  payload_jobs_log: typeof payload_jobs_log;
  payload_jobs: typeof payload_jobs;
  payload_folders: typeof payload_folders;
  payload_locked_documents: typeof payload_locked_documents;
  payload_locked_documents_rels: typeof payload_locked_documents_rels;
  payload_preferences: typeof payload_preferences;
  payload_preferences_rels: typeof payload_preferences_rels;
  payload_migrations: typeof payload_migrations;
  payload_query_presets: typeof payload_query_presets;
  payload_query_presets_rels: typeof payload_query_presets_rels;
  settings: typeof settings;
  settings_rels: typeof settings_rels;
  relations_users: typeof relations_users;
  relations_sessions: typeof relations_sessions;
  relations_accounts: typeof relations_accounts;
  relations_verifications: typeof relations_verifications;
  relations_passkeys: typeof relations_passkeys;
  relations_admin_invitations: typeof relations_admin_invitations;
  relations_orders_rels: typeof relations_orders_rels;
  relations_orders: typeof relations_orders;
  relations__orders_v_rels: typeof relations__orders_v_rels;
  relations__orders_v: typeof relations__orders_v;
  relations_files_rels: typeof relations_files_rels;
  relations_files: typeof relations_files;
  relations_tags: typeof relations_tags;
  relations_exports_texts: typeof relations_exports_texts;
  relations_exports: typeof relations_exports;
  relations_audit_log: typeof relations_audit_log;
  relations_payload_jobs_log: typeof relations_payload_jobs_log;
  relations_payload_jobs: typeof relations_payload_jobs;
  relations_payload_folders: typeof relations_payload_folders;
  relations_payload_locked_documents_rels: typeof relations_payload_locked_documents_rels;
  relations_payload_locked_documents: typeof relations_payload_locked_documents;
  relations_payload_preferences_rels: typeof relations_payload_preferences_rels;
  relations_payload_preferences: typeof relations_payload_preferences;
  relations_payload_migrations: typeof relations_payload_migrations;
  relations_payload_query_presets_rels: typeof relations_payload_query_presets_rels;
  relations_payload_query_presets: typeof relations_payload_query_presets;
  relations_settings_rels: typeof relations_settings_rels;
  relations_settings: typeof relations_settings;
};

declare module "@payloadcms/db-postgres" {
  export interface GeneratedDatabaseSchema {
    schema: DatabaseSchema;
  }
}
